<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        LEE KYUNTAE
    </title>
    <!-- Matter.js 물리 엔진 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;500;700&family=Montserrat:wght@400;800&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="ui-layer">
        <header class="site-header">
            <nav class="top-nav" aria-label="Primary">
                <div class="nav-left">
                    <a href="resume.html">RESUME</a>
                    <a href="info.html">INFO</a>
                </div>

                <h1 class="site-title">
                    <a class="brand" href="index.html" aria-label="Go to home">
                    <img src="assets/site-title-scaled.png" alt="LEE KYUNTAE" />
                    </a>
                </h1>

                <div class="nav-right">
                    <a href="project.html">PROJECT</a>
                </div>
                </nav>
                <p class="subtitle">LEE KYUNTAE DESIGN STUDIO</p>
        </header>
        <footer>
            <span>
            © 2025 LEE KYUNTAE <br>
            주소 : 의정부시 범골로29번길 34 \ 연락처 : 010-8758-2710 \ Contact : rbsxo0710@gmail.com
            </span>
        </footer>
    </div>

    <div id="loader">LOADING ASSETS...</div>

    <!-- 오른쪽 디테일 패널 -->
    <div id="detail-panel" class="detail-panel hidden">
        <button id="detail-close" class="detail-close" aria-label="Close detail">×</button>
        <div class="detail-image-wrapper">
            <img id="detail-image" src="" alt="Selected work">
        </div>
        <div class="detail-text">
            <h2 id="detail-title">Project title</h2>
            <p id="detail-description">
이 영역에는 각 작품에 대한 설명 텍스트가 들어갑니다.
예시) 촬영/제작 연도, 작업 의도, 사용한 매체, 프로젝트 배경 등을 간단히 기록할 수 있습니다.
            </p>
        </div>
    </div>

    <script>
        // ==========================================
        // [사용자 설정 영역]
        // ==========================================
        const MY_FILES = [
            '1.jpeg',
            '2.jpeg',
            '3.jpeg',
            '4.jpeg',
            '5.jpeg',
            '6.jpeg',
        ];

        // 각 이미지 메타 정보 (가안 텍스트)
        const IMAGE_META = [
            {
                title: "04 – Heartable / 2024",
                description: "인간 내면의 감정 변화를 몸 내부 장기의 움직임으로 치환하여\n표현한 연작 시리즈 중 하나. 순환 기관 중 심장을 가구로 재해석\n하였다. 심장을 손에 쥐고 있는 모양의 테이블 다리가 특징."
            },
            {
                title: "02 – Villustool / 2024",
                description: "인간 내면의 감정 변화를 몸 내부 장기의 움직임으로 치환하여 표현한 연작 시리즈 중 하나. 소화 기관 중 대장과 소장을 가구로 재해석하였다. 융털을 Fur 소재로 해석한 것이 특징이다."
            },
            {
                title: "03 – Bronchair / 2024",
                description: "인간 내면의 감정 변화를 몸 내부 장기의 움직임으로 치환하여 표현한 연작 시리즈 중 하나. 호흡 기관 중 폐와 폐포를 가구로 재해석하였다. 시팅부와 등받이에 공기를 채워넣은 것이 특징."
            },
            {
                title: "01 – Side Table No.01 / 2024",
                description: "해당 가구는 우리 일상 속 많은 비율을 차지하는 서양식 가구의 한국 적 재해석을 목표로 한다. 작가는 해당 가구를 통해, 건축과 가구에 존재하는 '수직구조물'에 대한 고찰을 심도있게 풀어낸다."
            },
            {
                title: "05 - 아더에러 스토어 디자인 제안 'EARTHPACE' / 2023",
                description: "의류 브랜드 아더에러의 스토어 디자인을 제안하였다. \"지구에서 가장 우주다운 공간은 '바다'이다\"라는 명제에서 출발하여, 해양 모티프를 활용하여 공간을 설계하였다."
            },
            {
                title: "06 -  LABBCCIN 스토어 디자인 제안 / 2025",
                description: "새니타이징 브랜드 LABCCIN의 스토어 디자인을 제안하였다. \"서울 중심에 있는 손닦기 거점\"라는 공간 콘셉트를 잡고 출발하여, 용리단길에 체험형 스토어 공간을 구성함."
            }
        ];

        const CONFIG = {
            folderPath: './assets/',   // 이미지 폴더 경로
            baseRadius: 100,
            hoverScale: 1.3,
            attractionStrength: 0.00005
        };

        // Matter.js alias
        const Engine = Matter.Engine,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Vector = Matter.Vector,
              Body = Matter.Body,
              Query = Matter.Query;

        let engine, runner, canvas, ctx, mouseConstraint, mouse;
        let width, height;

        // 디테일 패널 상태
        let isDetailOpen = false;
        let hoveredBody = null;

        // 디테일 패널 DOM
        const detailPanel = document.getElementById('detail-panel');
        const detailImageEl = document.getElementById('detail-image');
        const detailTitleEl = document.getElementById('detail-title');
        const detailDescEl = document.getElementById('detail-description');
        const detailCloseBtn = document.getElementById('detail-close');

        detailCloseBtn.addEventListener('click', () => {
            isDetailOpen = false;
            detailPanel.classList.add('hidden');
        });

        // 1. 이미지 경로 가공
        function getFullPaths() {
            return MY_FILES.map(filename => {
                if (filename.startsWith('http')) return filename;
                return CONFIG.folderPath + encodeURIComponent(filename);
            });
        }

        // 2. 엔진 초기화
        function setupEngine() {
            engine = Engine.create();
            engine.world.gravity.y = 0;

            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');
            document.body.appendChild(canvas);

            const handleResize = () => {
                width = window.innerWidth;
                height = window.innerHeight;

                const dpr = window.devicePixelRatio || 1;

                // scale 누적 방지
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;

                ctx.scale(dpr, dpr);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
            };

            window.addEventListener('resize', handleResize);
            handleResize();

            mouse = Mouse.create(canvas);
            mouse.pixelRatio = window.devicePixelRatio || 1;

            mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: { stiffness: 0.1, render: { visible: false } }
            });
            mouse.element.removeEventListener("mousewheel", mouse.mousewheel);
            mouse.element.removeEventListener("DOMMouseScroll", mouse.mousewheel);

            runner = Runner.create();
            Runner.run(runner, engine);

            // 클릭 이벤트 등록
            canvas.addEventListener('click', handleCanvasClick);

            startRenderLoop();
        }

        // 2-1. 클릭 시 어떤 버블을 눌렀는지 계산
        function handleCanvasClick(e) {
            // [중요 수정] 기존 코드에서 삭제된 부분:
            // if (mouseConstraint && mouseConstraint.body) return; 
            // -> 이 조건문 때문에 물체를 클릭해도 "드래그 중"으로 오판되어 함수가 멈췄습니다.

            const bodies = Composite.allBodies(engine.world);

            // [중요 수정] Matter.js의 mouse.position 대신, 
            // 현재 클릭 이벤트의 정확한 화면 좌표(clientX, clientY)를 사용합니다.
            const clickPosition = { x: e.clientX, y: e.clientY };

            // 해당 좌표에 있는 물체 찾기
            const hitBodies = Query.point(bodies, clickPosition);

            // 마우스 자체(Mouse Body)가 아닌, 우리가 만든 데이터가 있는 물체만 찾기
            const clickedBody = hitBodies.find(
                (b) => b.label !== "Mouse Body" && b.customData
            );

            if (clickedBody) {
                openDetailForBody(clickedBody);
            }
        }

        function openDetailForBody(body) {
            const data = body.customData;
            if (!data) return;

            const meta = IMAGE_META[data.id] || {
                title: "Untitled Work",
                description: "아직 설명이 등록되지 않은 작업입니다."
            };

            if (data.image && data.image.src) {
                detailImageEl.src = data.image.src;
            } else {
                detailImageEl.src = "";
            }
            detailImageEl.alt = meta.title;

            detailTitleEl.textContent = meta.title;
            detailDescEl.textContent = meta.description;

            isDetailOpen = true;
            detailPanel.classList.remove('hidden');
        }

        // 3. 버블 생성
        function createBubbles(loadedImages) {
            Composite.clear(engine.world);
            Composite.add(engine.world, mouseConstraint);

            const bodies = [];
            loadedImages.forEach((img, i) => {
                const randomScale = 0.8 + Math.random() * 0.4;
                const radius = CONFIG.baseRadius * randomScale;

                const x = width / 2 + (Math.random() - 0.5) * 200;
                const y = height / 2 + (Math.random() - 0.5) * 200;

                const body = Bodies.circle(x, y, radius, {
                    restitution: 0.5,
                    friction: 0.1,
                    frictionAir: 0.02,
                    customData: {
                        id: i,
                        originalRadius: radius,
                        currentRadius: radius,
                        targetRadius: radius,
                        image: img
                    }
                });
                bodies.push(body);
            });
            Composite.add(engine.world, bodies);
        }

        // 4. 렌더링 루프
        function startRenderLoop() {
            (function render() {
                window.requestAnimationFrame(render);

                // 디테일 패널이 열려 있으면 중심을 왼쪽으로 이동
                const centerX = isDetailOpen ? width * 0.3 : width / 2;
                const center = { x: centerX, y: height / 2 };

                const bodies = Composite.allBodies(engine.world);
                const mousePos = mouse.position;

                // hover 판정
                const query = Query.point(bodies, mousePos);
                hoveredBody = query.length > 0 ? query[0] : null;
                let foundHover = false;

                bodies.forEach(body => {
                    if (body.label === "Mouse Body") return;

                    // 중앙으로 끌어당기는 힘
                    if (body !== mouseConstraint.body) {
                        const forceVector = Vector.sub(center, body.position);
                        Body.applyForce(body, body.position, Vector.mult(forceVector, CONFIG.attractionStrength));
                    }

                    const data = body.customData;
                    if (!data) return;

                    if (body === hoveredBody && !mouseConstraint.body) {
                        data.targetRadius = data.originalRadius * CONFIG.hoverScale;
                        document.body.style.cursor = 'pointer';
                        foundHover = true;
                    } else {
                        data.targetRadius = data.originalRadius;
                    }

                    const diff = data.targetRadius - data.currentRadius;
                    if (Math.abs(diff) > 0.5) {
                        data.currentRadius += diff * 0.15;
                        const scaleFactor = data.currentRadius / body.circleRadius;
                        Body.scale(body, scaleFactor, scaleFactor);
                    }
                });

                if (!foundHover) {
                    document.body.style.cursor = 'default';
                }

                ctx.clearRect(0, 0, width, height);
                ctx.shadowColor = "rgba(0, 0, 0, 0.15)";
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 10;

                bodies.forEach(body => {
                    if (body.label === "Mouse Body") return;

                    const { x, y } = body.position;
                    const radius = body.circleRadius;
                    const data = body.customData;
                    if (!data) return;

                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = "#ffffff";
                    ctx.fill();
                    ctx.clip();

                    const img = data.image;
                    if (img && img.complete && img.naturalWidth !== 0) {
                        const scale = Math.max((radius * 2) / img.width, (radius * 2) / img.height);
                        const imgW = img.width * scale;
                        const imgH = img.height * scale;
                        const zoom = (body === hoveredBody) ? 1.1 : 1.0;

                        ctx.drawImage(
                            img,
                            x - (imgW * zoom) / 2,
                            y - (imgH * zoom) / 2,
                            imgW * zoom,
                            imgH * zoom
                        );
                    } else {
                        ctx.fillStyle = "#f4f4f5"; // 혹은 패널/배경과 비슷한 색
                        ctx.fill();
                    }
                    ctx.restore();
                });
            })();
        }

        // 5. 로딩 시작
        function start() {
            
            document.body.classList.add('loading');

            setupEngine();

            const paths = getFullPaths();
            const loaded = [];
            let count = 0;
            const total = paths.length;

            const onAllLoaded = () => {
                // 모든 이미지 로딩 완료 → 페이지 공개
                document.body.classList.remove('loading');

                const loader = document.getElementById('loader');
                if (loader) loader.style.opacity = '0';
                setTimeout(() => loader?.remove(), 500);

                createBubbles(loaded);
            };


            if (total === 0) {
                onAllLoaded();
                return;
            }

            paths.forEach(src => {
                const img = new Image();

                if (src.startsWith('http')) {
                    img.crossOrigin = "Anonymous";
                }

                img.onload = () => {
                    count++;
                    if (count === total) onAllLoaded();
                };
                img.onerror = () => {
                    console.warn("이미지 로드 실패:", src);
                    count++;
                    if (count === total) onAllLoaded();
                };
                img.src = src;
                loaded.push(img);
            });
        }

        start();
    </script>
</body>
</html>
