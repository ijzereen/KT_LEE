<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEE KYUNTAE</title>
    <!-- Matter.js 물리 엔진 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;500;700&family=Montserrat:wght@400;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #f4f4f5;
            font-family: 'Noto Sans KR', sans-serif;
            cursor: default;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            image-rendering: -webkit-optimize-contrast;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 40px;
        }

        header {
            opacity: 0;
            animation: fadeInDown 1s ease 0.5s forwards;
            text-align: center;
        }

        h1 {
            font-family: 'Montserrat', sans-serif;
            font-weight: 800;
            font-size: 2rem;
            color: #111;
            letter-spacing: -1px;
        }

        p.subtitle {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        footer {
            text-align: center;
            opacity: 0;
            animation: fadeInUp 1s ease 0.5s forwards;
        }

        footer span {
            font-size: 0.8rem;
            color: #888;
            display: block;
        }

        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            color: #333;
            z-index: 10;
            transition: opacity 0.5s;
        }

        /* 오른쪽 디테일 패널 */
        .detail-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 40%;
            height: 100%;
            background: rgba(250, 250, 250, 0.82);
            backdrop-filter: blur(14px);
            padding: 32px 28px;
            z-index: 3;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .detail-panel.hidden {
            display: none;
        }

        .detail-close {
            border: none;
            background: transparent;
            align-self: flex-end;
            font-size: 1.4rem;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            margin-bottom: 4px;
        }

        .detail-image-wrapper {
            flex: 1;
            border-radius: 16px;
            overflow: hidden;
            background:  rgba(250, 250, 250, 0.82);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .detail-image-wrapper img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
        }

        .detail-text {
            padding-top: 8px;
        }

        .detail-text h2 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #111;
        }

        .detail-text p {
            font-size: 0.85rem;
            line-height: 1.6;
            color: #444;
            white-space: pre-line;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 모바일에서 디테일 패널을 아래쪽에 붙이기 */
        @media (max-width: 768px) {
            .detail-panel {
                width: 100%;
                max-width: none;
                height: 45%;
                top: auto;
                bottom: 0;
                box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.08);
            }
        }
                /* 로딩 중에는 캔버스와 UI를 숨기고, 로더만 보이도록 */
        body.loading canvas,
        body.loading .ui-layer,
        body.loading #detail-panel {
            opacity: 0;
            pointer-events: none;
        }

        /* 로딩이 끝나면 자연스럽게 나타나도록 약간의 트랜지션 */
        canvas,
        .ui-layer,
        #detail-panel {
            transition: opacity 0.4s ease;
        }

    </style>
</head>
<body>

    <div class="ui-layer">
        <header>
            <h1>LEE KYUNTAE</h1>
            <p class="subtitle">Selected Works 2025</p>
        </header>
        <footer>
            <span>Hover to expand • Drag to move</span>
            <span>© 2025 LEE KYUNTAE</span>
        </footer>
    </div>

    <div id="loader">LOADING ASSETS...</div>

    <!-- 오른쪽 디테일 패널 -->
    <div id="detail-panel" class="detail-panel hidden">
        <button id="detail-close" class="detail-close" aria-label="Close detail">×</button>
        <div class="detail-image-wrapper">
            <img id="detail-image" src="" alt="Selected work">
        </div>
        <div class="detail-text">
            <h2 id="detail-title">Project title</h2>
            <p id="detail-description">
이 영역에는 각 작품에 대한 설명 텍스트가 들어갑니다.
예시) 촬영/제작 연도, 작업 의도, 사용한 매체, 프로젝트 배경 등을 간단히 기록할 수 있습니다.
            </p>
        </div>
    </div>

    <script>
        // ==========================================
        // [사용자 설정 영역]
        // ==========================================
        const MY_FILES = [
            '1.jpeg',
            '2.jpeg',
            '3.jpeg',
            '4.jpeg',
        ];

        // 각 이미지 메타 정보 (가안 텍스트)
        const IMAGE_META = [
            {
                title: "01 – Warm City Corners",
                description: "도시의 골목과 건물 모서리에 떨어지는 오후의 빛을 따라간 시리즈입니다.\n일상의 작은 순간들을 부드러운 톤으로 포착하는 데 집중했습니다."
            },
            {
                title: "02 – Quiet Objects",
                description: "사소한 오브제들을 테이블 위에 배치하고, 빛과 그림자만으로 분위기를 만든 스틸라이프 작업입니다.\n물성, 재질감, 간격이 주는 긴장을 다루고 있습니다."
            },
            {
                title: "03 – Between Windows",
                description: "창과 창 사이로 스치는 시선들을 기록한 프로젝트입니다.\n실내/실외, 개인/공간 사이의 경계를 시각적으로 풀어내는 실험입니다."
            },
            {
                title: "04 – Soft Structures",
                description: "건축적인 구조물을 부드러운 색감과 흐릿한 초점으로 재해석한 시리즈입니다.\n견고함과 유동성 사이의 모순된 느낌을 표현하는 데 초점을 두었습니다."
            },
            {
                title: "05 – Traces of Motion",
                description: "사람과 사물이 지나간 뒤 남는 흔적들을 단편적으로 기록한 작업입니다.\n완전한 순간보다, 비워진 자리와 잔상을 통해 스토리를 상상할 수 있도록 구성했습니다."
            },
            {
                title: "06 – Night Study",
                description: "도시의 밤 조명을 활용한 색채 스터디입니다.\n네온, 간판, 자동차 라이트 등이 만들어내는 우연한 색 조합과 리듬을 탐구한 프로젝트입니다."
            }
        ];

        const CONFIG = {
            folderPath: './assets/',   // 이미지 폴더 경로
            baseRadius: 100,
            hoverScale: 1.3,
            attractionStrength: 0.00005
        };

        // Matter.js alias
        const Engine = Matter.Engine,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Vector = Matter.Vector,
              Body = Matter.Body,
              Query = Matter.Query;

        let engine, runner, canvas, ctx, mouseConstraint, mouse;
        let width, height;

        // 디테일 패널 상태
        let isDetailOpen = false;
        let hoveredBody = null;

        // 디테일 패널 DOM
        const detailPanel = document.getElementById('detail-panel');
        const detailImageEl = document.getElementById('detail-image');
        const detailTitleEl = document.getElementById('detail-title');
        const detailDescEl = document.getElementById('detail-description');
        const detailCloseBtn = document.getElementById('detail-close');

        detailCloseBtn.addEventListener('click', () => {
            isDetailOpen = false;
            detailPanel.classList.add('hidden');
        });

        // 1. 이미지 경로 가공
        function getFullPaths() {
            return MY_FILES.map(filename => {
                if (filename.startsWith('http')) return filename;
                return CONFIG.folderPath + encodeURIComponent(filename);
            });
        }

        // 2. 엔진 초기화
        function setupEngine() {
            engine = Engine.create();
            engine.world.gravity.y = 0;

            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');
            document.body.appendChild(canvas);

            const handleResize = () => {
                width = window.innerWidth;
                height = window.innerHeight;

                const dpr = window.devicePixelRatio || 1;

                // scale 누적 방지
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;

                ctx.scale(dpr, dpr);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
            };

            window.addEventListener('resize', handleResize);
            handleResize();

            mouse = Mouse.create(canvas);
            mouse.pixelRatio = window.devicePixelRatio || 1;

            mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: { stiffness: 0.1, render: { visible: false } }
            });
            mouse.element.removeEventListener("mousewheel", mouse.mousewheel);
            mouse.element.removeEventListener("DOMMouseScroll", mouse.mousewheel);

            runner = Runner.create();
            Runner.run(runner, engine);

            // 클릭 이벤트 등록
            canvas.addEventListener('click', handleCanvasClick);

            startRenderLoop();
        }

        // 2-1. 클릭 시 어떤 버블을 눌렀는지 계산
        function handleCanvasClick(e) {
            // [중요 수정] 기존 코드에서 삭제된 부분:
            // if (mouseConstraint && mouseConstraint.body) return; 
            // -> 이 조건문 때문에 물체를 클릭해도 "드래그 중"으로 오판되어 함수가 멈췄습니다.

            const bodies = Composite.allBodies(engine.world);

            // [중요 수정] Matter.js의 mouse.position 대신, 
            // 현재 클릭 이벤트의 정확한 화면 좌표(clientX, clientY)를 사용합니다.
            const clickPosition = { x: e.clientX, y: e.clientY };

            // 해당 좌표에 있는 물체 찾기
            const hitBodies = Query.point(bodies, clickPosition);

            // 마우스 자체(Mouse Body)가 아닌, 우리가 만든 데이터가 있는 물체만 찾기
            const clickedBody = hitBodies.find(
                (b) => b.label !== "Mouse Body" && b.customData
            );

            if (clickedBody) {
                openDetailForBody(clickedBody);
            }
        }

        function openDetailForBody(body) {
            const data = body.customData;
            if (!data) return;

            const meta = IMAGE_META[data.id] || {
                title: "Untitled Work",
                description: "아직 설명이 등록되지 않은 작업입니다."
            };

            if (data.image && data.image.src) {
                detailImageEl.src = data.image.src;
            } else {
                detailImageEl.src = "";
            }
            detailImageEl.alt = meta.title;

            detailTitleEl.textContent = meta.title;
            detailDescEl.textContent = meta.description;

            isDetailOpen = true;
            detailPanel.classList.remove('hidden');
        }

        // 3. 버블 생성
        function createBubbles(loadedImages) {
            Composite.clear(engine.world);
            Composite.add(engine.world, mouseConstraint);

            const bodies = [];
            loadedImages.forEach((img, i) => {
                const randomScale = 0.8 + Math.random() * 0.4;
                const radius = CONFIG.baseRadius * randomScale;

                const x = width / 2 + (Math.random() - 0.5) * 200;
                const y = height / 2 + (Math.random() - 0.5) * 200;

                const body = Bodies.circle(x, y, radius, {
                    restitution: 0.5,
                    friction: 0.1,
                    frictionAir: 0.02,
                    customData: {
                        id: i,
                        originalRadius: radius,
                        currentRadius: radius,
                        targetRadius: radius,
                        image: img
                    }
                });
                bodies.push(body);
            });
            Composite.add(engine.world, bodies);
        }

        // 4. 렌더링 루프
        function startRenderLoop() {
            (function render() {
                window.requestAnimationFrame(render);

                // 디테일 패널이 열려 있으면 중심을 왼쪽으로 이동
                const centerX = isDetailOpen ? width * 0.3 : width / 2;
                const center = { x: centerX, y: height / 2 };

                const bodies = Composite.allBodies(engine.world);
                const mousePos = mouse.position;

                // hover 판정
                const query = Query.point(bodies, mousePos);
                hoveredBody = query.length > 0 ? query[0] : null;
                let foundHover = false;

                bodies.forEach(body => {
                    if (body.label === "Mouse Body") return;

                    // 중앙으로 끌어당기는 힘
                    if (body !== mouseConstraint.body) {
                        const forceVector = Vector.sub(center, body.position);
                        Body.applyForce(body, body.position, Vector.mult(forceVector, CONFIG.attractionStrength));
                    }

                    const data = body.customData;
                    if (!data) return;

                    if (body === hoveredBody && !mouseConstraint.body) {
                        data.targetRadius = data.originalRadius * CONFIG.hoverScale;
                        document.body.style.cursor = 'pointer';
                        foundHover = true;
                    } else {
                        data.targetRadius = data.originalRadius;
                    }

                    const diff = data.targetRadius - data.currentRadius;
                    if (Math.abs(diff) > 0.5) {
                        data.currentRadius += diff * 0.15;
                        const scaleFactor = data.currentRadius / body.circleRadius;
                        Body.scale(body, scaleFactor, scaleFactor);
                    }
                });

                if (!foundHover) {
                    document.body.style.cursor = 'default';
                }

                ctx.clearRect(0, 0, width, height);
                ctx.shadowColor = "rgba(0, 0, 0, 0.15)";
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 10;

                bodies.forEach(body => {
                    if (body.label === "Mouse Body") return;

                    const { x, y } = body.position;
                    const radius = body.circleRadius;
                    const data = body.customData;
                    if (!data) return;

                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = "#ffffff";
                    ctx.fill();
                    ctx.clip();

                    const img = data.image;
                    if (img && img.complete && img.naturalWidth !== 0) {
                        const scale = Math.max((radius * 2) / img.width, (radius * 2) / img.height);
                        const imgW = img.width * scale;
                        const imgH = img.height * scale;
                        const zoom = (body === hoveredBody) ? 1.1 : 1.0;

                        ctx.drawImage(
                            img,
                            x - (imgW * zoom) / 2,
                            y - (imgH * zoom) / 2,
                            imgW * zoom,
                            imgH * zoom
                        );
                    } else {
                        ctx.fillStyle = "#f4f4f5"; // 혹은 패널/배경과 비슷한 색
                        ctx.fill();
                    }
                    ctx.restore();
                });
            })();
        }

        // 5. 로딩 시작
        function start() {
            
            document.body.classList.add('loading');

            setupEngine();

            const paths = getFullPaths();
            const loaded = [];
            let count = 0;
            const total = paths.length;

            const onAllLoaded = () => {
                // 모든 이미지 로딩 완료 → 페이지 공개
                document.body.classList.remove('loading');

                const loader = document.getElementById('loader');
                if (loader) loader.style.opacity = '0';
                setTimeout(() => loader?.remove(), 500);

                createBubbles(loaded);
            };


            if (total === 0) {
                onAllLoaded();
                return;
            }

            paths.forEach(src => {
                const img = new Image();

                if (src.startsWith('http')) {
                    img.crossOrigin = "Anonymous";
                }

                img.onload = () => {
                    count++;
                    if (count === total) onAllLoaded();
                };
                img.onerror = () => {
                    console.warn("이미지 로드 실패:", src);
                    count++;
                    if (count === total) onAllLoaded();
                };
                img.src = src;
                loaded.push(img);
            });
        }

        start();
    </script>
</body>
</html>
